package lib

import (
	"fmt"
	"path/filepath"
	"slices"
	"strings"
)

type CppCodeGenerator struct {
	BaseCodeGenerator
}

func NewCppCodeGenerator() *CppCodeGenerator {
	newObj := new(CppCodeGenerator)

	return newObj
}

func (this *CppCodeGenerator) Close() {
	this.close()
}

func (this *CppCodeGenerator) Generate(
	descriptor *TableDescriptor,
	reader string, outputDir string, newLineType NewLineType) bool {

	this.init(descriptor, reader, newLineType)

	for _, def := range this.descriptor.GlobalStructs {
		underscoreName := UtilCamelToUnderscore(def.Name)

		headerFilePath := filepath.Join(outputDir, underscoreName+".h")
		headerFileContent := this.generateGlobalStructHeaderFile(def)
		if UtilWriteAllText(headerFilePath, headerFileContent) == false {
			return false
		}

		sourceFilePath := filepath.Join(outputDir, underscoreName+".cc")
		sourceFileContent := this.generateGlobalStructSourceFile(def)
		if UtilWriteAllText(sourceFilePath, sourceFileContent) == false {
			return false
		}
	}

	for _, def := range this.descriptor.Tables {
		underscoreName := UtilCamelToUnderscore(def.Name)

		headerFilePath := filepath.Join(outputDir, underscoreName+".h")
		headerFileContent := this.generateTableHeaderFile(def)
		if UtilWriteAllText(headerFilePath, headerFileContent) == false {
			return false
		}

		sourceFilePath := filepath.Join(outputDir, underscoreName+".cc")
		sourceFileContent := this.generateTableSourceFile(def)
		if UtilWriteAllText(sourceFilePath, sourceFileContent) == false {
			return false
		}
	}

	return true
}

func (this *CppCodeGenerator) getStructFieldCppType(
	fieldDef *StructFieldDef) string {

	cppType := ""
	if fieldDef.Type == StructFieldType_Int {
		cppType = "int32_t"
	} else if fieldDef.Type == StructFieldType_String {
		cppType = "std::string"
	}

	return cppType
}

func (this *CppCodeGenerator) getTableColumnCppType(
	columnDef *TableColumnDef) string {

	var checkType TableColumnType
	if columnDef.Type == TableColumnType_List {
		checkType = columnDef.ListType
	} else {
		checkType = columnDef.Type
	}

	cppType := ""
	if checkType == TableColumnType_Int {
		cppType = "int32_t"
	} else if checkType == TableColumnType_String {
		cppType = "std::string"
	} else if checkType == TableColumnType_Struct {
		cppType = columnDef.RefStructDef.Name
	}

	if columnDef.Type == TableColumnType_List {
		return fmt.Sprintf("std::vector<%s>", cppType)
	} else {
		return cppType
	}
}

func (this *CppCodeGenerator) generateGlobalStructHeaderFile(
	structDef *StructDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeGlobalStructHeaderFileIncludeGuardStart(&sb, structDef)
	this.writeGlobalStructHeaderFileIncludeFileDecl(&sb, structDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeHeaderFileOneStructDecl(&sb, structDef)
	this.writeNamespaceDeclEnd(&sb)
	this.writeGlobalStructHeaderFileIncludeGuardEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateGlobalStructSourceFile(
	structDef *StructDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeGlobalStructSourceFileIncludeFileDecl(&sb, structDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeSourceFileOneStructImpl(&sb, structDef)
	this.writeNamespaceDeclEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateTableHeaderFile(
	tableDef *TableDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeTableHeaderFileIncludeGuardStart(&sb, tableDef)
	this.writeTableHeaderFileIncludeFileDecl(&sb, tableDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeTableHeaderFileTableDecl(&sb, tableDef)
	this.writeNamespaceDeclEnd(&sb)
	this.writeTableHeaderFileIncludeGuardEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateTableSourceFile(
	tableDef *TableDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeTableSourceFileIncludeFileDecl(&sb, tableDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeTableSourceFileTableImpl(&sb, tableDef)
	this.writeNamespaceDeclEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) writeDontEditComment(
	sb *strings.Builder) {

	this.writeLine(sb,
		"/*")
	this.writeLine(sb,
		" * Generated by brickred table compiler.")
	this.writeLine(sb,
		" * Do not edit unless you are sure that you know what you are doing.")
	this.writeLine(sb,
		" */")
}

func (this *CppCodeGenerator) writeNamespaceDeclStart(
	sb *strings.Builder) {

	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok == false {
		return
	}
	namespaceName := strings.Join(readerDef.NamespaceParts, "::")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"namespace %s {",
		namespaceName)
}

func (this *CppCodeGenerator) writeNamespaceDeclEnd(
	sb *strings.Builder) {

	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok == false {
		return
	}
	namespaceName := strings.Join(readerDef.NamespaceParts, "::")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"} // namespace %s",
		namespaceName)
}

func (this *CppCodeGenerator) writeHeaderFileOneStructDecl(
	sb *strings.Builder, structDef *StructDef) {

	var indent string
	if structDef.ParentRef == nil {
		indent = ""
	} else {
		indent = "    "
	}

	if structDef.ParentRef == nil {
		this.writeEmptyLine(sb)
	}
	this.writeLineFormat(sb,
		"%sclass %s {",
		indent, structDef.Name)
	this.writeLineFormat(sb,
		"%spublic:",
		indent)
	this.writeLineFormat(sb,
		"%s    %s();",
		indent, structDef.Name)
	this.writeLineFormat(sb,
		"%s    ~%s();",
		indent, structDef.Name)
	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s    bool parse(const std::string &text);",
		indent)

	if len(structDef.Fields) > 0 {
		this.writeEmptyLine(sb)
		this.writeLineFormat(sb,
			"%spublic:",
			indent)

		for _, def := range structDef.Fields {
			cppType := this.getStructFieldCppType(def)
			this.writeLineFormat(sb,
				"%s    %s %s;",
				indent, cppType, def.Name)
		}
	}

	this.writeLineFormat(sb,
		"%s};",
		indent)
}

func (this *CppCodeGenerator) writeSourceFileOneStructImpl(
	sb *strings.Builder, structDef *StructDef) {

	this.writeSourceFileOneStructImplConstructor(sb, structDef)
	this.writeSourceFileOneStructImplDestructor(sb, structDef)
	this.writeSourceFileOneStructImplParseFunc(sb, structDef)
}

func (this *CppCodeGenerator) writeSourceFileOneStructImplConstructor(
	sb *strings.Builder, structDef *StructDef) {

	hasInitList := false
	lastInitListFieldIndex := -1

	for i, def := range structDef.Fields {
		if def.Type == StructFieldType_Int {
			hasInitList = true
			lastInitListFieldIndex = i
		}
	}

	parentClassPrefix := ""
	if structDef.ParentRef != nil {
		parentClassPrefix = fmt.Sprintf("%s::", structDef.ParentRef.Name)
	}

	this.writeEmptyLine(sb)
	if hasInitList {
		this.writeLineFormat(sb,
			"%s%s::%s() :",
			parentClassPrefix, structDef.Name, structDef.Name)
	} else {
		this.writeLineFormat(sb,
			"%s%s::%s()",
			parentClassPrefix, structDef.Name, structDef.Name)
	}

	if hasInitList {
		for i, def := range structDef.Fields {
			var defaultValue string
			if def.Type == StructFieldType_Int {
				defaultValue = "0"
			} else {
				continue
			}

			if i == lastInitListFieldIndex {
				this.writeLineFormat(sb,
					"    %s(%s)",
					def.Name, defaultValue)
			} else {
				this.writeLineFormat(sb,
					"    %s(%s),",
					def.Name, defaultValue)
			}
		}
	}

	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeSourceFileOneStructImplDestructor(
	sb *strings.Builder, structDef *StructDef) {

	parentClassPrefix := ""
	if structDef.ParentRef != nil {
		parentClassPrefix = fmt.Sprintf("%s::", structDef.ParentRef.Name)
	}

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s%s::~%s()",
		parentClassPrefix, structDef.Name, structDef.Name)
	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeSourceFileOneStructImplParseFunc(
	sb *strings.Builder, structDef *StructDef) {

	parentClassPrefix := ""
	if structDef.ParentRef != nil {
		parentClassPrefix = fmt.Sprintf("%s::", structDef.ParentRef.Name)
	}

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"bool %s%s::parse(const std::string &text)",
		parentClassPrefix, structDef.Name)
	this.writeLine(sb,
		"{")

	if len(structDef.Fields) <= 0 {
		this.writeLine(sb,
			"    return true;")
	} else {
		this.writeLine(sb,
			"    brickred::table::ColumnSpliter s(text, ';');")
		this.writeEmptyLine(sb)

		for _, def := range structDef.Fields {
			if def.Type == StructFieldType_Int {
				this.writeLineFormat(sb,
					"    if (s.nextInt(&this->%s) == false) {",
					def.Name)
				this.writeLine(sb,
					"        return false;")
				this.writeLine(sb,
					"    }")
			} else if def.Type == StructFieldType_String {
				this.writeLineFormat(sb,
					"    if (s.nextString(&this->%s) == false) {",
					def.Name)
				this.writeLine(sb,
					"        return false;")
				this.writeLine(sb,
					"    }")
			}
		}

		this.writeLine(sb,
			"    if (s.nextString(nullptr)) {")
		this.writeLine(sb,
			"        return false;")
		this.writeLine(sb,
			"    }")
		this.writeEmptyLine(sb)
		this.writeLine(sb,
			"    return true;")
	}

	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeGlobalStructHeaderFileIncludeGuardStart(
	sb *strings.Builder, structDef *StructDef) {

	guardNameParts := make([]string, 0)
	guardNameParts = append(guardNameParts, "BRICKRED_TABLE_GENERATED")
	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok {
		guardNameParts = append(
			guardNameParts, readerDef.NamespaceParts...)
	}
	guardNameParts = append(guardNameParts,
		g_notWordRegexp.ReplaceAllString(
			UtilCamelToUnderscore(structDef.Name), "_"))
	guardNameParts = append(guardNameParts, "H")
	guardName := strings.ToUpper(strings.Join(guardNameParts, "_"))

	this.writeLineFormat(sb,
		"#ifndef %s",
		guardName)
	this.writeLineFormat(sb, "#define %s",
		guardName)
}

func (this *CppCodeGenerator) writeGlobalStructHeaderFileIncludeGuardEnd(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#endif")
}

func (this *CppCodeGenerator) writeGlobalStructHeaderFileIncludeFileDecl(
	sb *strings.Builder, structDef *StructDef) {

	useCStdIntH := false

	for _, def := range structDef.Fields {
		if def.Type == StructFieldType_Int {
			useCStdIntH = true
		}
	}

	this.writeEmptyLine(sb)
	if useCStdIntH {
		this.writeLine(sb,
			"#include <cstdint>")
	}
	this.writeLine(sb,
		"#include <string>")
}

func (this *CppCodeGenerator) writeGlobalStructSourceFileIncludeFileDecl(
	sb *strings.Builder, structDef *StructDef) {

	this.writeLineFormat(sb,
		"#include \"%s.h\"",
		UtilCamelToUnderscore(structDef.Name))
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#include <brickred/table/column_spliter.h>")
}

func (this *CppCodeGenerator) writeTableHeaderFileIncludeGuardStart(
	sb *strings.Builder, tableDef *TableDef) {

	guardNameParts := make([]string, 0)
	guardNameParts = append(guardNameParts, "BRICKRED_TABLE_GENERATED")
	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok {
		guardNameParts = append(
			guardNameParts, readerDef.NamespaceParts...)
	}
	guardNameParts = append(guardNameParts,
		g_notWordRegexp.ReplaceAllString(
			UtilCamelToUnderscore(tableDef.Name), "_"))
	guardNameParts = append(guardNameParts, "H")
	guardName := strings.ToUpper(strings.Join(guardNameParts, "_"))

	this.writeLineFormat(sb,
		"#ifndef %s",
		guardName)
	this.writeLineFormat(sb, "#define %s",
		guardName)
}

func (this *CppCodeGenerator) writeTableHeaderFileIncludeGuardEnd(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#endif")
}

func (this *CppCodeGenerator) writeTableHeaderFileIncludeFileDecl(
	sb *strings.Builder, tableDef *TableDef) {

	useCStdIntH := false
	refStructDefs := make([]*StructDef, 0)

	for _, columnDef := range tableDef.Columns {
		var checkType TableColumnType
		if columnDef.Type == TableColumnType_List {
			checkType = columnDef.ListType
		} else {
			checkType = columnDef.Type
		}

		if checkType == TableColumnType_Int {
			useCStdIntH = true
		} else if checkType == TableColumnType_Struct {
			def := columnDef.RefStructDef
			if def == nil {
				continue
			}
			if def.ParentRef != nil {
				continue
			}
			if slices.Contains(refStructDefs, def) {
				continue
			}
			refStructDefs = append(refStructDefs, def)
		}
	}

	for _, structDef := range tableDef.LocalStructs {
		for _, def := range structDef.Fields {
			if def.Type == StructFieldType_Int {
				useCStdIntH = true
			}
		}
	}

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#include <cstddef>")
	if useCStdIntH {
		this.writeLine(sb,
			"#include <cstdint>")
	}
	this.writeLine(sb,
		"#include <string>")
	this.writeLine(sb,
		"#include <unordered_map>")
	this.writeLine(sb,
		"#include <vector>")

	if len(refStructDefs) > 0 {
		this.writeEmptyLine(sb)
	}
	for _, def := range refStructDefs {
		this.writeLineFormat(sb,
			"#include \"%s.h\"",
			UtilCamelToUnderscore(def.Name))
	}
}

func (this *CppCodeGenerator) writeTableHeaderFileTableDecl(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"class %s {",
		tableDef.Name)
	this.writeLine(sb,
		"public:")

	for _, def := range tableDef.LocalStructs {
		this.writeHeaderFileOneStructDecl(sb, def)
		this.writeEmptyLine(sb)
	}
	this.writeTableHeaderFileTableDeclRowClassDecl(sb, tableDef)
	this.writeEmptyLine(sb)
	this.writeTableHeaderFileTableDeclFuncDecl(sb, tableDef)
	this.writeEmptyLine(sb)
	this.writeTableHeaderFileTableDeclMemberDecl(sb, tableDef)

	this.writeLine(sb,
		"};")
}

func (this *CppCodeGenerator) writeTableHeaderFileTableDeclRowClassDecl(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeLine(sb,
		"    class Row {")
	this.writeLine(sb,
		"    public:")
	this.writeLine(sb,
		"        Row();")
	this.writeLine(sb,
		"        ~Row();")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public:")

	for _, def := range tableDef.Columns {
		cppType := this.getTableColumnCppType(def)
		this.writeLineFormat(sb,
			"        %s %s;",
			cppType, def.Name)
	}

	this.writeLine(sb,
		"    };")

	this.writeEmptyLine(sb)

	if tableDef.TableKeyType == TableKeyType_SingleKey {
		this.writeLine(sb,
			"    using Rows = std::vector<Row>;")
		this.writeLineFormat(sb,
			"    using RowIndex = std::unordered_map<%s, size_t>;",
			this.getTableColumnCppType(tableDef.TableKey))
	} else if tableDef.TableKeyType == TableKeyType_SetKey {
		this.writeLine(sb,
			"    using RowSet = std::vector<Row>;")
		this.writeLine(sb,
			"    using RowSets = std::vector<RowSet>;")
		this.writeLineFormat(sb,
			"    using RowSetIndex = std::unordered_map<%s, size_t>;",
			this.getTableColumnCppType(tableDef.TableKey))
	}
}

func (this *CppCodeGenerator) writeTableHeaderFileTableDeclFuncDecl(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeLineFormat(sb,
		"    %s();",
		tableDef.Name)
	this.writeLineFormat(sb,
		"    ~%s();",
		tableDef.Name)
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    bool parse(const std::string &text, std::string *error_info);")

	cppType := this.getTableColumnCppType(tableDef.TableKey)
	if tableDef.TableKey.Type == TableColumnType_String {
		cppType = fmt.Sprintf("const %s &", cppType)
	} else {
		cppType = fmt.Sprintf("%s ", cppType)
	}

	if tableDef.TableKeyType == TableKeyType_SingleKey {
		this.writeLineFormat(sb,
			"    const Row *getRow(%skey) const;",
			cppType)
		this.writeLine(sb,
			"    const Rows &getRows() const { return rows_; }")
	} else if tableDef.TableKeyType == TableKeyType_SetKey {
		this.writeLineFormat(sb,
			"    const RowSet *getRowSet(%skey) const;",
			cppType)
		this.writeLine(sb,
			"    const RowSets &getRowSets() const { return row_sets_; }")
	}
}

func (this *CppCodeGenerator) writeTableHeaderFileTableDeclMemberDecl(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeLine(sb,
		"private:")

	if tableDef.TableKeyType == TableKeyType_SingleKey {
		this.writeLine(sb,
			"    Rows rows_;")
		this.writeLine(sb,
			"    RowIndex row_index_;")
	} else if tableDef.TableKeyType == TableKeyType_SetKey {
		this.writeLine(sb,
			"    RowSets row_sets_;")
		this.writeLine(sb,
			"    RowSetIndex row_set_index_;")
	}
}

func (this *CppCodeGenerator) writeTableSourceFileIncludeFileDecl(
	sb *strings.Builder, tableDef *TableDef) {

	useCStdlibH := false
	useBrickredTableColumnSpliterH := false

	for _, def := range tableDef.Columns {
		if def.Type == TableColumnType_Int {
			useCStdlibH = true
		} else if def.Type == TableColumnType_Struct ||
			def.Type == TableColumnType_List {
			useBrickredTableColumnSpliterH = true
		}
	}

	this.writeLineFormat(sb,
		"#include \"%s.h\"",
		UtilCamelToUnderscore(tableDef.Name))

	this.writeEmptyLine(sb)
	if useCStdlibH {
		this.writeLine(sb,
			"#include <cstdlib>")
	}

	this.writeEmptyLine(sb)
	if useBrickredTableColumnSpliterH {
		this.writeLine(sb,
			"#include <brickred/table/column_spliter.h>")
	}
	this.writeLine(sb,
		"#include <brickred/table/line_reader.h>")
	this.writeLine(sb,
		"#include <brickred/table/util.h>")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImpl(
	sb *strings.Builder, tableDef *TableDef) {

	for _, def := range tableDef.LocalStructs {
		this.writeSourceFileOneStructImpl(sb, def)
	}
	this.writeTableSourceFileTableImplRowConstructor(sb, tableDef)
	this.writeTableSourceFileTableImplRowDestructor(sb, tableDef)
	this.writeTableSourceFileTableImplConstructor(sb, tableDef)
	this.writeTableSourceFileTableImplDestructor(sb, tableDef)
	this.writeTableSourceFileTableImplParseFunc(sb, tableDef)
	if tableDef.TableKeyType == TableKeyType_SingleKey {
		this.writeTableSourceFileTableImplGetRowFunc(sb, tableDef)
	} else if tableDef.TableKeyType == TableKeyType_SetKey {
		this.writeTableSourceFileTableImplGetRowSetFunc(sb, tableDef)
	}
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplRowConstructor(
	sb *strings.Builder, tableDef *TableDef) {

	hasInitList := false
	lastInitListFieldIndex := -1

	for i, def := range tableDef.Columns {
		if def.Type == TableColumnType_Int {
			hasInitList = true
			lastInitListFieldIndex = i
		}
	}

	this.writeEmptyLine(sb)
	if hasInitList {
		this.writeLineFormat(sb,
			"%s::Row::Row() :",
			tableDef.Name)
	} else {
		this.writeLineFormat(sb,
			"%s::Row::Row()",
			tableDef.Name)
	}

	if hasInitList {
		for i, def := range tableDef.Columns {
			var defaultValue string
			if def.Type == TableColumnType_Int {
				defaultValue = "0"
			} else {
				continue
			}

			if i == lastInitListFieldIndex {
				this.writeLineFormat(sb,
					"    %s(%s)",
					def.Name, defaultValue)
			} else {
				this.writeLineFormat(sb,
					"    %s(%s),",
					def.Name, defaultValue)
			}
		}
	}

	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplRowDestructor(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s::Row::~Row()",
		tableDef.Name)
	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplConstructor(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s::%s()",
		tableDef.Name, tableDef.Name)
	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplDestructor(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s::~%s()",
		tableDef.Name, tableDef.Name)
	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplParseFunc(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"bool %s::parse(const std::string &text, std::string *error_info)",
		tableDef.Name)
	this.writeLine(sb,
		"{")

	this.writeLine(sb,
		"    brickred::table::LineReader r(text);")
	this.writeLine(sb, ""+
		"    const brickred::table::LineReader::LineBuffer "+
		"*line_buffer = nullptr;")
	this.writeLineFormat(sb,
		"    size_t column_count_req = %d;",
		len(tableDef.Columns))

	this.writeTableSourceFileTableImplParseFuncReadCommentLine(sb)
	this.writeTableSourceFileTableImplParseFuncReadNameLine(sb, tableDef)

	if tableDef.TableKeyType == TableKeyType_SingleKey {
		this.writeTableSourceFileTableImplParseFuncSingleKeyReadDataLine(
			sb, tableDef)
	} else if tableDef.TableKeyType == TableKeyType_SetKey {
		this.writeTableSourceFileTableImplParseFuncSetKeyReadDataLine(
			sb, tableDef)
	}

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    *error_info = \"\";")
	this.writeLine(sb,
		"    return true;")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplParseFuncReadCommentLine(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    // read comment line")
	this.writeLine(sb,
		"    line_buffer = r.nextLine();")
	this.writeLine(sb,
		"    if (line_buffer == nullptr) {")
	this.writeLine(sb,
		"        *error_info = \"comment line is required\";")
	this.writeLine(sb,
		"        return false;")
	this.writeLine(sb,
		"    }")
	this.writeLine(sb,
		"    if (line_buffer->size() != column_count_req) {")
	this.writeLine(sb,
		"        *error_info = brickred::table::util::error(")
	this.writeLine(sb, ""+
		"            \"comment line column count %zd is invalid, "+
		"should be %zd\",")
	this.writeLine(sb,
		"            line_buffer->size(), column_count_req);")
	this.writeLine(sb,
		"        return false;")
	this.writeLine(sb,
		"    }")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplParseFuncReadNameLine(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    // read name line")
	this.writeLine(sb,
		"    line_buffer = r.nextLine();")
	this.writeLine(sb,
		"    if (line_buffer == nullptr) {")
	this.writeLine(sb,
		"        *error_info = \"name line is required\";")
	this.writeLine(sb,
		"        return false;")
	this.writeLine(sb,
		"    }")
	this.writeLine(sb,
		"    if (line_buffer->size() != column_count_req) {")
	this.writeLine(sb,
		"        *error_info = brickred::table::util::error(")
	this.writeLine(sb, ""+
		"            \"name line column count %zd is invalid, "+
		"should be %zd\",")
	this.writeLine(sb,
		"            line_buffer->size(), column_count_req);")
	this.writeLine(sb,
		"        return false;")
	this.writeLine(sb,
		"    }")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        size_t col_number = 0;")
	this.writeEmptyLine(sb)
	for _, def := range tableDef.Columns {
		this.writeLineFormat(sb,
			"        if ((*line_buffer)[col_number++] != \"%s\") {",
			def.Name)
		this.writeLine(sb,
			"            *error_info = brickred::table::util::error(")
		this.writeLineFormat(sb, ""+
			"                \"column %%zd should be named as `%s`\", "+
			"col_number);",
			def.Name)
		this.writeLine(sb,
			"            return false;")
		this.writeLine(sb,
			"        }")
	}
	this.writeLine(sb,
		"    }")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplParseFuncSingleKeyReadDataLine(
	sb *strings.Builder, tableDef *TableDef) {

	keyFormat := ""
	keyValue := ""
	if tableDef.TableKey.Type == TableColumnType_Int {
		keyFormat = "%d"
		keyValue = fmt.Sprintf("row.%s", tableDef.TableKey.Name)
	} else if tableDef.TableKey.Type == TableColumnType_String {
		keyFormat = "%s"
		keyValue = fmt.Sprintf("row.%s.c_str()", tableDef.TableKey.Name)
	}

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    // read data lines")
	this.writeLine(sb,
		"    size_t line_number = 3;")
	this.writeLine(sb,
		"    rows_.clear();")
	this.writeLine(sb,
		"    row_index_.clear();")
	this.writeLine(sb,
		"    for (;;) {")
	this.writeLine(sb,
		"        line_buffer = r.nextLine();")
	this.writeLine(sb,
		"        if (line_buffer == nullptr) {")
	this.writeLine(sb,
		"            break;")
	this.writeLine(sb,
		"        }")
	this.writeLine(sb,
		"        if (line_buffer->size() != column_count_req) {")
	this.writeLine(sb,
		"            *error_info = brickred::table::util::error(")
	this.writeLine(sb, ""+
		"                \"line %zd column count %zd is invalid, "+
		"should be %zd\",")
	this.writeLine(sb,
		"                line_number, line_buffer->size(), column_count_req);")
	this.writeLine(sb,
		"            return false;")
	this.writeLine(sb,
		"        }")
	this.writeLineFormat(sb,
		"        if ((*line_buffer)[%d].empty()) {",
		tableDef.TableKeyColumnIndex)
	this.writeLine(sb,
		"            *error_info = brickred::table::util::error(")
	this.writeLineFormat(sb,
		"                \"line %%zd key `%s` is empty\", line_number);",
		tableDef.TableKey.Name)
	this.writeLine(sb,
		"            return false;")
	this.writeLine(sb,
		"        }")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"        Row row;")
	this.writeLine(sb,
		"        size_t col_number = 0;")
	this.writeEmptyLine(sb)
	this.writeTableSourceFileTableImplParseFuncParseColumns(sb, tableDef)
	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"        if (getRow(row.%s) != nullptr) {",
		tableDef.TableKey.Name)
	this.writeLine(sb,
		"            *error_info = brickred::table::util::error(")
	this.writeLineFormat(sb, ""+
		"                \"line %%zd key `%s` value %s is duplicated\", "+
		"line_number, %s);",
		tableDef.TableKey.Name, keyFormat, keyValue)
	this.writeLine(sb,
		"            return false;")
	this.writeLine(sb,
		"        }")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"        rows_.push_back(row);")
	this.writeLineFormat(sb,
		"        row_index_.insert(std::make_pair(row.%s, rows_.size() - 1));",
		tableDef.TableKey.Name)
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"        line_number += 1;")
	this.writeLine(sb,
		"    }")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplParseFuncSetKeyReadDataLine(
	sb *strings.Builder, tableDef *TableDef) {

	keyDefine := "";
	keyFormat := "";
	keyValue := "";
	if tableDef.TableKey.Type == TableColumnType_Int {
		keyDefine = "int32_t key = ::atoi(key_str->c_str())"
		keyFormat = "%d"
		keyValue = fmt.Sprintf("row.%s", tableDef.TableKey.Name)
	} else if tableDef.TableKey.Type == TableColumnType_String {
		keyDefine = "std::string key = *key_str"
		keyFormat = "%s"
		keyValue = fmt.Sprintf("row.%s.c_str()", tableDef.TableKey.Name)
	}

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    // read data lines")
	this.writeLine(sb,
		"    size_t line_number = 3;")
	this.writeLine(sb,
		"    std::string last_key;")
	this.writeLine(sb,
		"    row_sets_.clear();")
	this.writeLine(sb,
		"    row_set_index_.clear();")
	this.writeLine(sb,
		"    for (;;) {")
	this.writeLine(sb,
		"        line_buffer = r.nextLine();")
	this.writeLine(sb,
		"        if (line_buffer == nullptr) {")
	this.writeLine(sb,
		"            break;")
	this.writeLine(sb,
		"        }")
	this.writeLine(sb,
		"        if (line_buffer->size() != column_count_req) {")
	this.writeLine(sb,
		"            *error_info = brickred::table::util::error(")
	this.writeLine(sb, ""+
		"                \"line %zd column count %zd is invalid, "+
		"should be %zd\",")
	this.writeLine(sb,
		"                line_number, line_buffer->size(), column_count_req);")
	this.writeLine(sb,
		"            return false;")
	this.writeLine(sb,
		"        }")
	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"        const std::string *key_str = &(*line_buffer)[%d];",
		tableDef.TableKeyColumnIndex)
	this.writeLine(sb,
		"        if (key_str->empty()) {")
	this.writeLine(sb,
		"            if (last_key.empty() == false) {")
	this.writeLine(sb,
		"                key_str = &last_key;")
	this.writeLine(sb,
		"            } else {")
	this.writeLine(sb,
		"                *error_info = brickred::table::util::error(")
	this.writeLineFormat(sb,
		"                    \"line %%zd key `%s` is empty\", line_number);",
		tableDef.TableKey.Name)
	this.writeLine(sb,
		"                return false;")
	this.writeLine(sb,
		"            }")
	this.writeLine(sb,
		"        }")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"        Row row;")
	this.writeLine(sb,
		"        size_t col_number = 0;")
	this.writeEmptyLine(sb)
	this.writeTableSourceFileTableImplParseFuncParseColumns(sb, tableDef)
	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"        %s;",
		keyDefine)
	this.writeLine(sb,
		"        if (*key_str != last_key) {")
	this.writeLine(sb,
		"            if (getRowSet(key) != nullptr) {")
	this.writeLine(sb,
		"                *error_info = brickred::table::util::error(")
	this.writeLineFormat(sb,
		"                    \"line %%zd key `%s` value %s is duplicated\",",
		tableDef.TableKey.Name, keyFormat)
	this.writeLineFormat(sb,
		"                    line_number, %s);",
		keyValue)
	this.writeLine(sb,
		"                return false;")
	this.writeLine(sb,
		"            }")
	this.writeLine(sb,
		"            RowSet &row_set = row_sets_.emplace_back();")
	this.writeLine(sb,
		"            row_set.push_back(row);")
	this.writeLine(sb,
		"            row_set_index_.insert(std::make_pair(key, row_sets_.size() - 1));")
	this.writeLine(sb,
		"            last_key = *key_str;")
	this.writeLine(sb,
		"        } else {")
	this.writeLineFormat(sb,
		"            row.%s = key;",
		tableDef.TableKey.Name)
	this.writeLine(sb,
		"            RowSet &row_set = row_sets_[row_set_index_[key]];")
	this.writeLine(sb,
		"            row_set.push_back(row);")
	this.writeLine(sb,
		"        }")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"        line_number += 1;")
	this.writeLine(sb,
		"    }")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplParseFuncParseColumns(
	sb *strings.Builder, tableDef *TableDef) {

	for _, def := range tableDef.Columns {
		isList := def.Type == TableColumnType_List
		var checkType TableColumnType
		if def.Type == TableColumnType_List {
			checkType = def.ListType
		} else {
			checkType = def.Type
		}

		if checkType == TableColumnType_Int {
			if isList {
				this.writeLineFormat(sb, ""+
					"        brickred::table::util::readColumnIntList("+
					"(*line_buffer)[col_number++], &row.%s);",
					def.Name)
			} else {
				this.writeLineFormat(sb,
					"        row.%s = ::atoi((*line_buffer)[col_number++].c_str());",
					def.Name)
			}
		} else if checkType == TableColumnType_String {
			if isList {
				this.writeLineFormat(sb, ""+
					"        brickred::table::util::readColumnStringList("+
					"(*line_buffer)[col_number++], &row.%s);",
					def.Name)
			} else {
				this.writeLineFormat(sb,
					"        row.%s = (*line_buffer)[col_number++];",
					def.Name)
			}
		} else if checkType == TableColumnType_Struct {
			if isList {
				this.writeLine(sb,
					"        if (brickred::table::util::readColumnStructList(")
				this.writeLineFormat(sb, ""+
					"                (*line_buffer)[col_number++], "+
					"&row.%s) == false) {",
					def.Name)
				this.writeLine(sb,
					"            *error_info = brickred::table::util::error(")
				this.writeLineFormat(sb, ""+
					"                \"line %%zd column `%s` value is invalid\", "+
					"line_number);",
					def.Name)
				this.writeLine(sb,
					"            return false;")
				this.writeLine(sb,
					"        }")
			} else {
				this.writeLineFormat(sb, ""+
					"        if (row.%s.parse("+
					"(*line_buffer)[col_number++]) == false) {",
					def.Name)
				this.writeLine(sb,
					"            *error_info = brickred::table::util::error(")
				this.writeLineFormat(sb, ""+
					"                \"line %%zd column `%s` value is invalid\", "+
					"line_number);",
					def.Name)
				this.writeLine(sb,
					"            return false;")
				this.writeLine(sb,
					"        }")
			}
		}
	}
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplGetRowFunc(
	sb *strings.Builder, tableDef *TableDef) {

	cppType := this.getTableColumnCppType(tableDef.TableKey)
	if tableDef.TableKey.Type == TableColumnType_String {
		cppType = fmt.Sprintf("const %s &", cppType)
	} else {
		cppType = fmt.Sprintf("%s ", cppType)
	}

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"const %s::Row *%s::getRow(%skey) const",
		tableDef.Name, tableDef.Name, cppType)
	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"    RowIndex::const_iterator iter = row_index_.find(key);")
	this.writeLine(sb,
		"    if (iter == row_index_.end()) {")
	this.writeLine(sb,
		"        return nullptr;")
	this.writeLine(sb,
		"    }")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    return &rows_[iter->second];")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeTableSourceFileTableImplGetRowSetFunc(
	sb *strings.Builder, tableDef *TableDef) {
}
