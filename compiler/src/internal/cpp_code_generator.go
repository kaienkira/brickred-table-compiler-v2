package lib

import (
	"fmt"
	"path/filepath"
	"slices"
	"strings"
)

type CppCodeGenerator struct {
	BaseCodeGenerator
}

func NewCppCodeGenerator() *CppCodeGenerator {
	newObj := new(CppCodeGenerator)

	return newObj
}

func (this *CppCodeGenerator) Close() {
	this.close()
}

func (this *CppCodeGenerator) Generate(
	descriptor *TableDescriptor,
	reader string, outputDir string, newLineType NewLineType) bool {

	this.init(descriptor, reader, newLineType)

	for _, def := range this.descriptor.GlobalStructs {
		underscoreName := UtilCamelToUnderscore(def.Name)

		headerFilePath := filepath.Join(outputDir, underscoreName+".h")
		headerFileContent := this.generateGlobalStructHeaderFile(def)
		if UtilWriteAllText(headerFilePath, headerFileContent) == false {
			return false
		}

		sourceFilePath := filepath.Join(outputDir, underscoreName+".cc")
		sourceFileContent := this.generateGlobalStructSourceFile(def)
		if UtilWriteAllText(sourceFilePath, sourceFileContent) == false {
			return false
		}
	}

	for _, def := range this.descriptor.Tables {
		underscoreName := UtilCamelToUnderscore(def.Name)

		headerFilePath := filepath.Join(outputDir, underscoreName+".h")
		headerFileContent := this.generateTableHeaderFile(def)
		if UtilWriteAllText(headerFilePath, headerFileContent) == false {
			return false
		}

		sourceFilePath := filepath.Join(outputDir, underscoreName+".cc")
		sourceFileContent := this.generateTableSourceFile(def)
		if UtilWriteAllText(sourceFilePath, sourceFileContent) == false {
			return false
		}
	}

	return true
}

func (this *CppCodeGenerator) getStructFieldCppType(
	fieldDef *StructFieldDef) string {

	cppType := ""
	if fieldDef.Type == StructFieldType_Int {
		cppType = "int32_t"
	} else if fieldDef.Type == StructFieldType_String {
		cppType = "std::string"
	}

	return cppType
}

func (this *CppCodeGenerator) getTableColumnCppType(
	columnDef *TableColumnDef) string {

	var checkType TableColumnType
	if columnDef.Type == TableColumnType_List {
		checkType = columnDef.ListType
	} else {
		checkType = columnDef.Type
	}

	cppType := ""
	if checkType == TableColumnType_Int {
		cppType = "int32_t"
	} else if checkType == TableColumnType_String {
		cppType = "std::string"
	} else if checkType == TableColumnType_Struct {
		cppType = columnDef.RefStructDef.Name
	}

	if columnDef.Type == TableColumnType_List {
		return fmt.Sprintf("std::vector<%s>", cppType)
	} else {
		return cppType
	}
}

func (this *CppCodeGenerator) generateGlobalStructHeaderFile(
	structDef *StructDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeGlobalStructHeaderFileIncludeGuardStart(&sb, structDef)
	this.writeGlobalStructHeaderFileIncludeFileDecl(&sb, structDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeHeaderFileOneStructDecl(&sb, structDef)
	this.writeNamespaceDeclEnd(&sb)
	this.writeGlobalStructHeaderFileIncludeGuardEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateGlobalStructSourceFile(
	structDef *StructDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeGlobalStructSourceFileIncludeFileDecl(&sb, structDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeSourceFileOneStructImpl(&sb, structDef)
	this.writeNamespaceDeclEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateTableHeaderFile(
	tableDef *TableDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeTableHeaderFileIncludeGuardStart(&sb, tableDef)
	this.writeTableHeaderFileIncludeFileDecl(&sb, tableDef)
	this.writeNamespaceDeclStart(&sb)
	this.writeTableHeaderFileTableDecl(&sb, tableDef)
	this.writeNamespaceDeclEnd(&sb)
	this.writeTableHeaderFileIncludeGuardEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateTableSourceFile(
	tableDef *TableDef) string {

	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeNamespaceDeclStart(&sb)
	this.writeNamespaceDeclEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) writeDontEditComment(
	sb *strings.Builder) {

	this.writeLine(sb,
		"/*")
	this.writeLine(sb,
		" * Generated by brickred table compiler.")
	this.writeLine(sb,
		" * Do not edit unless you are sure that you know what you are doing.")
	this.writeLine(sb,
		" */")
}

func (this *CppCodeGenerator) writeNamespaceDeclStart(
	sb *strings.Builder) {

	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok == false {
		return
	}
	namespaceName := strings.Join(readerDef.NamespaceParts, "::")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"namespace %s {",
		namespaceName)
}

func (this *CppCodeGenerator) writeNamespaceDeclEnd(
	sb *strings.Builder) {

	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok == false {
		return
	}
	namespaceName := strings.Join(readerDef.NamespaceParts, "::")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"} // namespace %s",
		namespaceName)
}

func (this *CppCodeGenerator) writeHeaderFileOneStructDecl(
	sb *strings.Builder, structDef *StructDef) {

	var indent string
	if structDef.ParentRef == nil {
		indent = ""
	} else {
		indent = "    "
	}

	if structDef.ParentRef == nil {
		this.writeEmptyLine(sb)
	}
	this.writeLineFormat(sb,
		"%sclass %s {",
		indent, structDef.Name)
	this.writeLineFormat(sb,
		"%spublic:",
		indent)
	this.writeLineFormat(sb,
		"%s    %s();",
		indent, structDef.Name)
	this.writeLineFormat(sb,
		"%s    ~%s();",
		indent, structDef.Name)
	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s    bool parse(const std::string &text);",
		indent)

	if len(structDef.Fields) > 0 {
		this.writeEmptyLine(sb)
		this.writeLineFormat(sb,
			"%spublic:",
			indent)

		for _, def := range structDef.Fields {
			cppType := this.getStructFieldCppType(def)
			this.writeLineFormat(sb,
				"%s    %s %s;",
				indent, cppType, def.Name)
		}
	}

	this.writeLineFormat(sb,
		"%s};",
		indent)
}

func (this *CppCodeGenerator) writeSourceFileOneStructImpl(
	sb *strings.Builder, structDef *StructDef) {

	this.writeSourceFileOneStructImplConstructor(sb, structDef)
	this.writeSourceFileOneStructImplDestructor(sb, structDef)
	this.writeSourceFileOneStructImplParseFunc(sb, structDef)
}

func (this *CppCodeGenerator) writeSourceFileOneStructImplConstructor(
	sb *strings.Builder, structDef *StructDef) {

	hasInitList := false
	lastInitListFieldIndex := -1

	for i, def := range structDef.Fields {
		if def.Type == StructFieldType_String {
			continue
		}
		hasInitList = true
		lastInitListFieldIndex = i
	}

	parentClassPrefix := ""
	if structDef.ParentRef != nil {
		parentClassPrefix = fmt.Sprintf("%s::", structDef.ParentRef.Name)
	}

	this.writeEmptyLine(sb)
	if hasInitList {
		this.writeLineFormat(sb,
			"%s%s::%s() :",
			parentClassPrefix, structDef.Name, structDef.Name)
	} else {
		this.writeLineFormat(sb,
			"%s%s::%s()",
			parentClassPrefix, structDef.Name, structDef.Name)
	}

	if hasInitList {
		for i, def := range structDef.Fields {
			var defaultValue string
			if def.Type == StructFieldType_Int {
				defaultValue = "0"
			} else {
				continue
			}

			if i == lastInitListFieldIndex {
				this.writeLineFormat(sb,
					"    %s(%s)",
					def.Name, defaultValue)
			} else {
				this.writeLineFormat(sb,
					"    %s(%s),",
					def.Name, defaultValue)
			}
		}
	}

	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeSourceFileOneStructImplDestructor(
	sb *strings.Builder, structDef *StructDef) {

	parentClassPrefix := ""
	if structDef.ParentRef != nil {
		parentClassPrefix = fmt.Sprintf("%s::", structDef.ParentRef.Name)
	}

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"%s%s::~%s()",
		parentClassPrefix, structDef.Name, structDef.Name)
	this.writeLine(sb,
		"{")
	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeSourceFileOneStructImplParseFunc(
	sb *strings.Builder, structDef *StructDef) {

	parentClassPrefix := ""
	if structDef.ParentRef != nil {
		parentClassPrefix = fmt.Sprintf("%s::", structDef.ParentRef.Name)
	}

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"bool %s%s::parse(const std::string &text)",
		parentClassPrefix, structDef.Name)
	this.writeLine(sb,
		"{")

	if len(structDef.Fields) <= 0 {
		this.writeLine(sb,
			"    return true;")
	} else {
		this.writeLine(sb,
			"    brickred::table::ColumnSpliter s(text, ';');")
		this.writeEmptyLine(sb)

		for _, def := range structDef.Fields {
			if def.Type == StructFieldType_Int {
				this.writeLineFormat(sb,
					"    if (s.nextInt(&this->%s) == false) {",
					def.Name)
				this.writeLine(sb,
					"        return false;")
				this.writeLine(sb,
					"    }")
			} else if def.Type == StructFieldType_String {
				this.writeLineFormat(sb,
					"    if (s.nextString(&this->%s) == false) {",
					def.Name)
				this.writeLine(sb,
					"        return false;")
				this.writeLine(sb,
					"    }")
			}
		}

		this.writeLine(sb,
			"    if (s.nextString(nullptr)) {")
		this.writeLine(sb,
			"        return false;")
		this.writeLine(sb,
			"    }")
		this.writeEmptyLine(sb)
		this.writeLine(sb,
			"    return true;")
	}

	this.writeLine(sb,
		"}")
}

func (this *CppCodeGenerator) writeGlobalStructHeaderFileIncludeGuardStart(
	sb *strings.Builder, structDef *StructDef) {

	guardNameParts := make([]string, 0)
	guardNameParts = append(guardNameParts, "BRICKRED_TABLE_GENERATED")
	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok {
		guardNameParts = append(
			guardNameParts, readerDef.NamespaceParts...)
	}
	guardNameParts = append(guardNameParts,
		g_notWordRegexp.ReplaceAllString(
			UtilCamelToUnderscore(structDef.Name), "_"))
	guardNameParts = append(guardNameParts, "H")
	guardName := strings.ToUpper(strings.Join(guardNameParts, "_"))

	this.writeLineFormat(sb,
		"#ifndef %s",
		guardName)
	this.writeLineFormat(sb, "#define %s",
		guardName)
}

func (this *CppCodeGenerator) writeGlobalStructHeaderFileIncludeGuardEnd(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#endif")
}

func (this *CppCodeGenerator) writeGlobalStructHeaderFileIncludeFileDecl(
	sb *strings.Builder, structDef *StructDef) {

	useCStdIntH := false

	for _, def := range structDef.Fields {
		if def.Type == StructFieldType_Int {
			useCStdIntH = true
		}
	}

	this.writeEmptyLine(sb)
	if useCStdIntH {
		this.writeLine(sb,
			"#include <cstdint>")
	}
	this.writeLine(sb,
		"#include <string>")
}

func (this *CppCodeGenerator) writeGlobalStructSourceFileIncludeFileDecl(
	sb *strings.Builder, structDef *StructDef) {

	this.writeLineFormat(sb,
		"#include \"%s.h\"",
		UtilCamelToUnderscore(structDef.Name))
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#include <brickred/table/column_spliter.h>")
}

func (this *CppCodeGenerator) writeTableHeaderFileIncludeGuardStart(
	sb *strings.Builder, tableDef *TableDef) {

	guardNameParts := make([]string, 0)
	guardNameParts = append(guardNameParts, "BRICKRED_TABLE_GENERATED")
	readerDef, ok := this.descriptor.Readers[this.reader]
	if ok {
		guardNameParts = append(
			guardNameParts, readerDef.NamespaceParts...)
	}
	guardNameParts = append(guardNameParts,
		g_notWordRegexp.ReplaceAllString(
			UtilCamelToUnderscore(tableDef.Name), "_"))
	guardNameParts = append(guardNameParts, "H")
	guardName := strings.ToUpper(strings.Join(guardNameParts, "_"))

	this.writeLineFormat(sb,
		"#ifndef %s",
		guardName)
	this.writeLineFormat(sb, "#define %s",
		guardName)
}

func (this *CppCodeGenerator) writeTableHeaderFileIncludeGuardEnd(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#endif")
}

func (this *CppCodeGenerator) writeTableHeaderFileIncludeFileDecl(
	sb *strings.Builder, tableDef *TableDef) {

	useCStdIntH := false
	refStructDefs := make([]*StructDef, 0)

	for _, columnDef := range tableDef.Columns {
		var checkType TableColumnType
		if columnDef.Type == TableColumnType_List {
			checkType = columnDef.ListType
		} else {
			checkType = columnDef.Type
		}

		if checkType == TableColumnType_Int {
			useCStdIntH = true
		} else if checkType == TableColumnType_Struct {
			def := columnDef.RefStructDef
			if def == nil {
				continue
			}
			if def.ParentRef != nil {
				continue
			}
			if slices.Contains(refStructDefs, def) {
				continue
			}
			refStructDefs = append(refStructDefs, def)
		}
	}

	for _, structDef := range tableDef.LocalStructs {
		for _, def := range structDef.Fields {
			if def.Type == StructFieldType_Int {
				useCStdIntH = true
			}
		}
	}

	this.writeEmptyLine(sb)
	if useCStdIntH {
		this.writeLine(sb,
			"#include <cstdint>")
	}
	this.writeLine(sb,
		"#include <string>")
	this.writeLine(sb,
		"#include <unordered_map>")
	this.writeLine(sb,
		"#include <vector>")

	this.writeEmptyLine(sb)
	for _, def := range refStructDefs {
		this.writeLineFormat(sb,
			"#include \"%s.h\"",
			UtilCamelToUnderscore(def.Name))
	}
}

func (this *CppCodeGenerator) writeTableHeaderFileTableDecl(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"class %s {",
		tableDef.Name)
	this.writeLine(sb,
		"public:")

	for _, def := range tableDef.LocalStructs {
		this.writeHeaderFileOneStructDecl(sb, def)
		this.writeEmptyLine(sb)
	}
	this.writeTableHeaderFileTableDeclRowClassDecl(sb, tableDef)
	this.writeEmptyLine(sb)

	this.writeLine(sb,
		"};")
}

func (this *CppCodeGenerator) writeTableHeaderFileTableDeclRowClassDecl(
	sb *strings.Builder, tableDef *TableDef) {

	this.writeLine(sb,
		"    class Row {")
	this.writeLine(sb,
		"    public:")
	this.writeLine(sb,
		"        Row();")
	this.writeLine(sb,
		"        ~Row();")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public:")

	for _, def := range tableDef.Columns {
		cppType := this.getTableColumnCppType(def)
		this.writeLineFormat(sb,
			"        %s %s;",
			cppType, def.Name)
	}

	this.writeLine(sb,
		"    };")
}
